\documentclass[11pt, english]{article}
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage[spanish]{babel}
\selectlanguage{spanish}
\usepackage[utf8]{inputenc}
\usepackage[svgnames]{xcolor}
\usepackage{booktabs}
\usepackage[flushleft]{threeparttable}

\usepackage{listings}
\usepackage{afterpage}

\pagestyle{plain}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
%\lstset{language=R,
%    basicstyle=\small\ttfamily,
%   stringstyle=\color{DarkGreen},
%    otherkeywords={0,1,2,3,4,5,6,7,8,9},
%    morekeywords={TRUE,FALSE},
%    deletekeywords={data,frame,length,as,character},
%    keywordstyle=\color{blue},
%    commentstyle=\color{DarkGreen},
%}

\lstset{frame=tb,
language=R,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
numbers=none,
keywordstyle=\color{blue},
numberstyle=\tiny\color{gray},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3,
escapeinside={(@}{@)}
}

\usepackage{here}


\textheight=21cm
\textwidth=17cm
%\topmargin=-1cm
\oddsidemargin=0cm
\parindent=0mm
\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%
% La siguiente instrucciÃ³n pone el curso automÃ¡ticamente%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{color}
\usepackage{ragged2e}

\global\let\date\relax
\newcounter{unomenos}
\setcounter{unomenos}{\number\year}
\addtocounter{unomenos}{-1}
\stepcounter{unomenos}
\gdef\@date{ Curso  2018 / \arabic{unomenos}}

\begin{document}

\begin{titlepage}

\begin{center}
\vspace*{-1in}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{../res/pics/logo.jpg}
\end{center}
\end{figure}

\vspace*{0.4in}
\begin{large}
\textsc{Procesadores de Lenguaje}:\\
\end{large}
\vspace*{0.2in}
\begin{Large}
\textbf{\textsc{Nombre de nuestro lenguaje}} \\
\end{Large}
\vspace*{0.3in}
\begin{large}
\@date\\
\end{large}
\vspace*{0.3in}
\rule{80mm}{0.1mm}\\
\vspace*{0.1in}
\begin{large}
Realizado por: \\

Medina Medina, David Alberto  \\
Brito Ramos, Christian  \\
Hernández Delgado, Christopher \\
López González, Néstor \\
\vspace*{0.3in}
\end{large}
\includegraphics[width=3cm]{../res/pics/LogoEscuela.jpg}
\end{center}
\end{titlepage}

\newcommand{\CC}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}

\tableofcontents
\newpage

\section{Definición del lenguaje (Autor: Quien termine antes)}\label{Introduction}
Introducir breve introducción del lenguaje que planteamos.
\newpage

\subsection{Tipos de datos (David)}\label{data-type}
Cualquier leguaje de programación necesita definir un conjunto de \emph{tipos de datos}, esto es, la batería de valores y operaciones que puede adquirir una variable. Cada tipo de dato está definido en el lenguaje por un \emph{literal} único que lo representa, lo que permite que cada tipo de dato tenga un representación física específica.

Los tipos de datos definidos en el lenguaje son los que figuran en el \emph{cuadro \ref{tab:table1}}. Las características críticas de implementación que define a cada tipo son:

\begin{description}
	\item[Entero] Representa a todas y cada una de las variables enteras que sean declaradas en el lenguaje. Este tipo de dato presenta un tamaño de 4 bytes (32 bits) y permite representar números enteros con signo. El \emph{complemento a 2} es el sistema elegido para definir el signo del número entero. Este dato se representa por el literal \texttt{int}. El rango de valores que puede tomar es

	\begin{equation}\label{eq:equation1}
		\left [-2^{N-1},\: 2^{N-1}-1 \right ] = \left [-2^{32-1},\: 2^{32-1}-1 \right] = \left [-2147483648,\: 2147483647 \right]
	\end{equation}

	donde, $N$ es el número de bits disponibles para representar el número entero (32 bits).
	\item[Coma flotante de simple precisión] Este tipo de dato representa número reales en coma flotante de simple precisión con un tamaño de 4 bytes (32 bits) siguiendo el estándar \emph{IEEE 754}. En la figura \ref{fig:figure1} puede observarse como esta representación binaria los bits se organizan en tres sectores principales:
	\begin{itemize}
		\item \textbf{Signo} (1 bit). Se trata de un sólo bit que define el signo del número: positivo (0) o negativo (1).
		\item  \textbf{Exponente (8bits)}. Se trata de un número entero con signo de complemento a 2 ($\left [ -128,\: 127\right ]$)
		\item \textbf{Mantisa (23 bits)}. Conforma la fracción a la derecha de la coma binaria y un bit de encabezado implícito.
	\end{itemize}
	Este tipo de dato se representa con el literal \texttt{real}. Su rango de valores es de $\left [ 1.18 \cdot 10^{–38},\; 3.4 \cdot 10^{38} \right ]$.
	\begin{figure}[H]\label{fig:figure1}
		\centering
		\includegraphics[width=0.75\textwidth]{../res/pics/data-types/float_diag.png}
		\caption{Representación binaria de número en coma flotante de simple precisión (\emph{IEEE 754})}
	\end{figure}

	\item[Caracter] Este tipo de dato es usado para representar caracteres con la codificación \emph{ASCII}, es por este motivo que el tamaño de que ocupan las variables de tipo caracter son de 1 byte de tamaño, siendo \texttt{char} el literal que lo representa.
	\item[Booleano] Se trata de un tipo de dato utilizado para representar representar valores booleanos. Su tamaño es de 1 bit, por lo que tan solo puede tomar dos valores: \texttt{1} (verdadero) ó \texttt{0} (falso). El literal que lo representa es \texttt{bool}.
\end{description}

\begin{table}[h!]
	\begin{center}
		\caption{Tipos de datos}
		\label{tab:table1}
		\begin{tabular}{l|l|l|l}
			\toprule
			\textbf{Tipo} & \textbf{Literal} & \textbf{Tamaño} & \textbf{Rango}\\
			\midrule
			Entero & int &4 Bytes & $\left [-2147483648,\: 2147483647 \right]$\\
			Coma flotante de simple precisión & real & 4 Byte & $\left [ 1.18 \cdot 10^{–38},\; 3.4 \cdot 10^{38} \right ]$\\
			Caracter & char & 1 Byte & $\left [ \texttt{0x00 - 0xFF} \right ]$\\
			Lógico & bool & 1 Bit & $\left [0,\; 1 \right ]$\\
			\bottomrule
		\end{tabular}
	\end{center}
\end{table}

En el siguiente ejemplo se muestra cómo se declaran las variables con los literales de los tipos descritos anteriormente:

\lstinputlisting[language=C++]{../res/lst/data-types/data-type.x}

\subsection{Colecciones de datos: \texttt{Arrays}}\label{arrays}
Las variables pueden ser agrupadas en colecciones de datos de una dimensión denominados \texttt{arrays}. En este lenguaje, cualquier tipo de dato puede formar parte de un \texttt{array}.

Para declarar un \texttt{array} del tipo que se desee, debe usar la gramática \ref{grammar:1.2.1}:
	\begin{equation}\label{grammar:1.2.1}
		tipo[<int>]\; nombre\_variable
	\end{equation}

donde el $tipo$ define el tipo de dato e $<int>$ un valor entero opcional que define el tamaño del \texttt{array}. Cuando no se indica este último valor entero, no se lleva a término la reserva en memoria del \texttt{array} declarado. En caso contrario, se reservará en memoria tantos bytes/bits como fueren necesarios para generar una colección de tipos de datos del tamaño indicado por $<int>$. El número de bytes/bits a reservar está determinado por el tipo de dato y el tamaño del \texttt{array},
	\begin{equation}\label{eq:1.2}
		Tamano_{memoria} = Tamano_{tipo\, dato} \times Tamano_{array}
	\end{equation}

Un \texttt{array} que ha sido declarado con anterioridad puede ser redefinido haciendo uso de la gramática \ref{grammar:1.2.2},
	\begin{equation}\label{grammar:1.2.2}
	tipo[ \, ]\; nombre\_variable = new\; tipo[<int>]\; \{ \\
	expresion\_1, expresion\_2, ...\;\}
	\end{equation}

Esta notación es alternativa a la gramática \ref{grammar:1.2.1}, donde podremos inicializar el \texttt{array} a un conjunto de expresiones separados por comas encerrados dentro de los caracteres \texttt{\{} y \texttt{\}}. Estas expresiones son opcionales. El tamaño máximo del vector y, por tanto, de expresiones es el indicado por $<int>$ el cual es un número entero de caracter obligatorio.

Si se declara un \texttt{array} utilizando la gramática \ref{grammar:1.2.1} o \ref{grammar:1.2.2} sin expresiones en esta última, el array es inicializado en todas sus posiciones al valor \texttt{0} para tipos de datos enteros y reales. Para caracteres el valor por defecto es el caracter \texttt{nulo}. Y para tipos booleanos el valor por defecto es \texttt{FALSE}.

La gramática \ref{grammar:1.2.3} es necesaria para acceder al valor de un elemento del \texttt{array} en una posición arbitraria del mismo,
	\begin{equation}\label{grammar:1.2.3}
	nombre\_variable\; [<int>]
	\end{equation}
donde $<int>$ es un entero obligatorio que indica la posición del \texttt{array} a la que se desea acceder.

El \texttt{array} de caracteres constituyen los denominados \texttt{string}, los cuales requieren una atención especial ya que es posible cargar una variable con una secuencia de caracteres sin ser necesaria la declaración dada por la gramática \ref{grammar:1.2.2}. La gramática \ref{grammar:1.2.4} define la instancia de un \texttt{string} con un conjunto de caracteres localizados entre los caracteres comillas doble,

	\begin{equation}\label{grammar:1.2.4}
	nombre\_variable\; = " <char><char>..."
	\end{equation}

El siguiente listado muestra algunos ejemplos de uso de los \texttt{array} definidos en este lenguaje:

\lstinputlisting[language=C++]{../res/lst/array/array.x}

\subsection{Palabras reservadas (Christian)}\label{keywords}
Aquí va el texto. Poner siempre un código de ejemplo.
\newpage

\subsection{Comentarios (Christian)}\label{commentaries}
Aquí va el texto. Poner siempre un código de ejemplo.
\newpage

\subsection{Tipos de operadores}\label{operators}
Aquí va el texto. Poner siempre un código de ejemplo.

\subsubsection{Operadores aritméticos (David)}\label{arithmetic-operators}
<<<<<<< HEAD
Estos operadores son necesarios para realizar operaciones matemáticas sencillas. La descripción detallada de cada uno de estos operadores queda reflejado en la tabla \ref{tab:arithmetic}.

\begin{table}[h!]
	\begin{center}
		\caption{Operadores aritméticos}\label{tab:arithmetic}
		\begin{threeparttable}
			\begin{tabular}{l|l|l|l|l|l}
				\toprule
				\textbf{Operación} & \textbf{Tipo operación} & \textbf{Lexema} & \textbf{Estructura} & \textbf{Tipo entrada} & \textbf{Tipo salida} \tnote{1}\\
				\midrule
				Suma  & Binaria & \texttt{+} & \texttt{\{Expr\} + \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Resta & Binaria & \texttt{-} & \texttt{\{Expr\} - \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Multiplicación & Binaria & \texttt{*} & \texttt{\{Expr\} * \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				División & Binaria & \texttt{/} & \texttt{\{Expr\} / \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Módulo & Binaria & \texttt{\%} & \texttt{\{Expr\}\, \% \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Potencia & Binaria & \texttt{**} & \texttt{\{Expr\} ** \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Raíz & Binaria & \texttt{\#} & \texttt{\{Expr\} \# \{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Pre-incremento \tnote{2} & Unaria & \texttt{++} & ++\texttt{\{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Pre-decremento \tnote{2} & Unaria & \texttt{--} & --\texttt{\{Expr\}} & \texttt{int/real} & \texttt{int/real}\\
				Post-incremento \tnote{3} & Unaria & \texttt{++} & \texttt{\{Expr\}++} & \texttt{int/real} & \texttt{int/real}\\
				Post-decremento \tnote{3} & Unaria & \texttt{--} & \texttt{\{Expr\}--} & \texttt{int/real} & \texttt{int/real}\\
				\bottomrule
			\end{tabular}
			\begin{tablenotes}
				\small
				\item[1] Todas las operaciones binarias permiten entremezclar el uso de un valor entero y otro real al mismo tiempo aunque esto conllevaría el \textit{casteo} del resultado de la operación a un valor de tipo real.
				\item [2] El valor de la variable es incrementado/decrementado una unidad previa asignación del mismo.
				\item[3] El valor de la variable es incrementada/decrementada una unidad después de asignar el valor del misma.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}
=======
Aquí va el texto. Poner siempre un código de ejemplo.
\newpage
>>>>>>> b176eca2bf7daa7c743937d81ea7cc81f6583270

\subsubsection{Operadores lógicos (Christopher)}
Definimos los símbolos que identificarán a los operadores lógicos de forma análoga a los utilizados por gran parte de otros lenguajes de programación, separando cada operador 2 expresiones a comparar por los operadores lógicos a utilizar, con la excepción del propio \emph{NOT}, que podrá utilizarse directamente para determinar si el valor devuelto por una expresión de tipo \texttt{booleano} es directamente verdadero o no. Como dato adicional, también consideramos la posibilidad de hacer uso de comparadores mediante dichos operadores lógicos n-arios, comparando pares de expresiones entre sí de forma sucesiva siguiendo el orden de lectura de izquierda a derecha (que a efectos prácticos es lo mismo que hacer sucesivos \emph{AND} pero de forma más breve) y la posibilidad de prioridades para ciertos operadores (como el \emph{AND}). \vspace{0px}

En relación a las expresiones de comparación, consideramos hacer que de momento solo se puedan utilizar entre tipos de datos del mismo tipo o similar (por ejemplo, entre enteros y reales podría hacerse). Dejamos la tabla de operadores como sigue: \vspace{0px}
\begin{table}[h!]
	\begin{center}
		\caption{Tipos de operadores lógicos}
		\label{tab:table2}
		\begin{tabular}{c|c|c|c}
		\toprule
		\multicolumn{1}{c}{\textbf{Operador}} & \multicolumn{1}{c}{\textbf{Símbolo}} & \multicolumn{1}{c}{\textbf{Formato}}      & \multicolumn{1}				{c}{\textbf{Tipos de datos comparables}}
		\\ \midrule
		AND                            & \&\&                         & \{EXPR\} \&\& \{EXPR\}            & LOGICO - LOGICO                                                                                                                                  		\\ \midrule
		OR                             & \textbar\textbar                           & \{EXPR\} \textbar\textbar$ \; $\{EXPR\}              & LOGICO - LOGICO                                                                                                                                  		\\ \midrule
		NOT                            & !                            & !\{EXPR\}                         & LOGICO                                                                                                                                           		\\ \midrule
		IGUAL                          & ==                           & \{EXPR\} == \{EXPR\}              & \begin{tabular}[c]{@{}c@{}}LOGICO - LOGICO \\ ENTERO - 		ENTERO  \\  ENTERO - REAL  \\ REAL - REAL  \\  CHAR - CHAR  \\ ARRAY{[}CHAR{]} - ARRAY{[}CHAR{]}\end{tabular} \\ \midrule
		NOIGUAL                        & !=                           & \{EXPR\} != \{EXPR\}              & \begin{tabular}[c]{@{}c@{}}LOGICO - LOGICO \\ ENTERO - 		ENTERO  \\  ENTERO - REAL  \\ REAL - REAL  \\  CHAR - CHAR  \\  ARRAY{[}CHAR{]} - ARRAY{[}CHAR{]}\end{tabular} \\ \midrule
		MAYOR                          & \textgreater{}               & \{EXPR\} \textgreater $ \; $\{EXPR\}    & \begin{tabular}[c]{@{}c@{}}ENTERO - ENTERO  \\  		ENTERO - REAL \\ REAL - REAL\end{tabular}                                                                \\ \midrule
		MAYORIGUAL                     & \textgreater{}=              & \{EXPR\} \textgreater{}= \{EXPR\} & \begin{tabular}[c]{@{}c@{}}ENTERO - ENTERO  \\  		ENTERO - REAL \\ REAL - REAL\end{tabular}
		\end{tabular}
	\end{center}
\end{table}
\newpage
\begin{table}[h!]
	\begin{center}
		\begin{tabular}{c|c|c|c}
\multicolumn{1}{c|}{\textcolor{white}{\textbf{Operador}}} & \multicolumn{1}{c|}{\textcolor{white}{\textbf{Símbolo}}} & \multicolumn{1}{c|}{\textcolor{white}{\textbf{Formato}}}      & \multicolumn{1}				{c}{\textcolor{white}{ARRAY{[}CHAR{]} - ARRAY{[}CHAR{]}}}
		\\ \midrule
			MENOR                          & \textless{}                  & \{EXPR\} \textless $ \; $\{EXPR\}       & \begin{tabular}[c]{@{}c@{}}ENTERO - ENTERO \\\ ENTERO - REAL \\ REAL - REAL\end{tabular}                                                                \\ \midrule
			MENORIGUAL                     & \textless{}=                 & \{EXPR\} \textless{}= \{EXPR\}    & \begin{tabular}[c]{@{}c@{}}ENTERO - ENTERO \\ 		ENTERO - REAL \\ REAL - REAL\end{tabular}
		\\ \bottomrule
		\end{tabular}
	\end{center}
\end{table}


A continuación mostramos un ejemplo de uso de los operadores lógicos para un caso trivial meramente ejemplificativo:
\begin{lstlisting}[frame=single]
int a = 7
int suma = 0
5 <= a < 10 ?:
	suma = 4 * a

suma > 20 > a && 2*suma != 32 < a
	suma++
\end{lstlisting}

\subsubsection{Operadores bit a bit (David)}\label{bitwise-operators}
Estos operadores permiten manipular los valores de una expresión a nivel de bits. El cuadro \ref{tab:bitwise} refleja la descripción detallada de cada uno de estos operadores.

\begin{table}[h!]
	\begin{center}
		\caption{Operadores bit a bit}\label{tab:bitwise}
		\begin{threeparttable}
			\begin{tabular}{l|l|l|l|l|l}
				\toprule
				\textbf{Operación} & \textbf{Tipo operación} & \textbf{Lexema} & \textbf{Estructura} & \textbf{Tipo entrada} & \textbf{Tipo salida}\\
				\midrule
				\texttt{AND} & Binaria & \texttt{\&} &  \texttt{\{Expr\} \& \{Expr\}} & Cualquiera & Cualquiera\\
				\texttt{OR} & Binaria & \texttt{|} &  \texttt{\{Expr\} | \{Expr\}} & Cualquiera & Cualquiera\\
				\texttt{XOR} & Binaria & \texttt{\textasciicircum} &  \texttt{\{Expr\} \textasciicircum \, \{Expr\}} & Cualquiera & Cualquiera\\
				Desp. izq. & Unaria & \texttt{\textless\textless} &  \texttt{\{Expr\} \textless\textless\, \{Expr\}}\tnote{1}\,& Cualquiera & Cualquiera\\
				Desp. dcha. & Unaria & \texttt{\textgreater\textgreater} & \texttt{\{Expr\} \textgreater\textgreater\, \{Expr\}}\tnote{1}\, & Cualquiera & Cualquiera\\
				\bottomrule
			\end{tabular}
			\begin{tablenotes}
				\small
				\item[1] Rota los bits de la expresión de la izquierda tantas unidades a la izquierda/derecha como indique la expresión de la derecha.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}

\subsubsection{Operadores de array (Néstor)}
Aquí va el texto. Poner siempre un código de ejemplo.
\newpage

\subsection{Estructuras de control}
Aquí va el texto. Poner siempre un código de ejemplo.

\subsubsection{Sentencias \texttt{if-ifelse-else} (Néstor)}\label{if}
Aquí va el texto. Poner siempre un código de ejemplo.

\subsubsection{Bucle \texttt{for-forelse-else} (Christopher)}
La estructura de control evaluará un conjunto de expresiones hasta alcanzar los símbolos que hemos utilizado para definir bucles, el "\texttt{??}". Posteriormente se puede especificar una expresión que se usará comúnmente como modificador del valor de iteración empleado en la condición, aunque no es estrictamente necesario que en la condición figure el parámetro utilizado en la iteración, si por ejemplo se definen otras formas de salida dentro del contexto del bucle, y si se cumple la condición evaluada se ejecutarán las instrucciones dentro del contexto en caso de que el conjunto de condiciones del bucle se cumpla. Se ha considerado hacer que exista el \texttt{for-else}, que actuaría de tal manera que si no se cumple inicialmente la condición del primer bucle, comprobará la expresión del siguiente, y si su condición se cumple, estará evaluando repetidamente las instrucciones de este último (sin volver a comparar con las condiciones del bucle anterior al \texttt{else}). De esta manera, podemos hacer una estructura combinada de lo que en otros casos serían \texttt{if-for-else-for}, de forma directa con solo un \texttt{for-else}. \vspace{10px}

De forma análoga a los \texttt{else} de las expresiones condicionales, la representación para el \texttt{for-else} hará uso también del símbolo "." para indicar un \texttt{else} y sucesivamente los que pudiesen añadirse tras este, tantos como se deseen, considerando que el último else, al no tener condición de entrada como tal, se ejecutará una sola vez. En caso de que se aniden, hay que considerar que los cierres de contexto dependen del número de tabulaciones que hayan. A continuación se muestra un ejemplo de uso:
\begin{lstlisting}[frame=single]
int a = 7
int b = 9
int suma = 0
int contador = 0

a > contador ?? contador++:
	suma = suma + a * contador + b
. b > contador ?? contador++:
	suma = suma + b*contador + a
.??:
	suma = a + b
(@\textcolor[rgb]{0,0.5,0}{.. Como 'a' es mayor que 'contador' inicialmente, solo se ejecutan instrucciones del primer bucle} @)
\end{lstlisting}

\subsubsection{Bucle \texttt{while-whileelse-else} (Christian)}\label{while}
Aquí va el texto. Poner siempre un código de ejemplo.


\subsection{Funciones (David)}\label{functions}
Las funciones componen una estructura fundamental en cualquier lenguaje de programación que son útiles para estructurar funcionalmente el código en diferentes contextos, aportando una mayor expresividad del lenguaje.

Una función puede ser declarada sin especificar el código que se ejecutará dentro de su contexto. La forma general de declaración puede observarse en el listado \ref{lst:fun-declaration}.

\lstinputlisting[language=C++,caption=Declaracion de funciones\label{lst:fun-declaration}]{../res/lst/function/function-declaration.x}

La definición de cualquier función sigue la estructura del listado \ref{lst:fun-definition}. El cuerpo de la función debe comenzar por el caracter de cambio de contexto (caracter \texttt{0x09} o cuatro caracteres \texttt{0x20} seguidos). 

\lstinputlisting[language=C++,firstline=1,lastline=7, showlines=true, caption=Declaracion de funciones\label{lst:fun-definition}]{../res/lst/function/function-definition.x}

El listado \ref{lst:fun-use} ilustra la estructura general de llamada a una función.

\lstinputlisting[language=C++,firstline=1,lastline=7, showlines=true, caption=Declaracion de funciones\label{lst:fun-use}]{../res/lst/function/function-use.x}

Es importante recalcar que la referencia en memoria de un array es leída cuando este es usado como parámetro de una función. Si un array es el valor de retorno de una función, se devuelve su referencia en memoria. 


\newpage

\subsection{Funciones primitivas (Néstor)}\label{primitive-functions}
Aquí va el texto. Poner siempre un código de ejemplo.
\newpage

\subsection{Código ejemplo (Christopher)}\label{example-code}
Aquí va el código de ejemplo con el que probaremos nuestro compilador.

\end{document}
